# Задача 4: Наибольшая общая подпоследовательность двух последовательностей

## Описание

Этот код вычисляет длину самой длинной общей подпоследовательности двух числовых последовательностей, считанных из файла, проверяет корректность входных данных, записывает результат в файл и выводит информацию о времени выполнения и памяти.
### Формат входных данных
- Входные данные находятся в файле input.txt.
- Первая строка: n - длина первой последовательности.
- Вторая строка: a1, a2, ..., an через пробел.
- Третья строка: m - длина второй последовательности.
- Четвертая строка: b1, b2, ..., bm через пробел.
- Ограничения: 1 ≤ n,m ≤ 100; −10^9 < ai, bi < 10^9.

### Формат выходных данных
- Выводится число p.

### Ограничения
- Время выполнения: 1 секунда.
- Память: 64 МБ.

## Структура проекта
```
lab7/
|--   task4/
|     |-- src/
|     |     |-- task4.py      # Реализация алгоритма
|     |-- tests/
|     |     |-- test_task4.py       # Тесты
|     |-- txtf/
|     |     |-- input.txt     # Входные данные
|     |     |-- output.txt    # Выходные данные
```
## Код задачи
```
# Импортируем библиотеки для отслеживания памяти и времени выполнения программы
import tracemalloc
import time
from lab7.utils import *

# Запускаем таймер для измерения времени работы программы
t_start = time.perf_counter()

# Включаем отслеживание памяти
tracemalloc.start()

current_dir = os.path.dirname(os.path.abspath(__file__))  # Директория task/src
txtf_dir = os.path.join(os.path.dirname(current_dir), "txtf")  # Директория task/txtf
input_path = os.path.join(txtf_dir, "input.txt")


def longest_common_subsequence(n, A, m, B):
    """
    Вычисляет длину самой длинной общей подпоследовательности для последовательностей A и B.
    """
    # Инициализация DP-таблицы
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    # Заполнение таблицы
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if A[i - 1] == B[j - 1]:  # Элементы совпадают
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:  # Элементы не совпадают
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # Результат — последняя ячейка таблицы
    return dp[n][m]


# Основной блок программы
if __name__ == "__main__":
    # Читаем данные из файла input.txt с помощью функции open_file
    input_data = open_file(input_path)

    # Преобразуем входные данные
    n = int(input_data[0].strip())  # Длина первой последовательности
    A = list(map(int, input_data[1].strip().split()))  # Первая последовательность
    m = int(input_data[2].strip())  # Длина второй последовательности
    B = list(map(int, input_data[3].strip().split()))  # Вторая последовательность

    # Проверка корректности входных данных
    if (1 <= n <= 100) and (1 <= m <= 100) and (all(-10**9 < x < 10**9 for x in A + B)):
        print(f"Task 4\nInput:\n{n} {A}\n{m} {B}")
        delete_prev_values(4)

        # Вычисляем длину самой длинной общей подпоследовательности
        result = longest_common_subsequence(n, A, m, B)

        output_path = get_output_path(4)
        # Записываем результат в файл output.txt
        write_file(str(result), output_path)
        print_output_file(4)
    else:
        # Выводим сообщение об ошибке, если данные некорректны
        print("Введите корректные данные")

    # Выводим время работы программы
    print("Время работы: %s секунд" % (time.perf_counter() - t_start))
    # Выводим количество памяти, затраченной на выполнение программы
    print("Затрачено памяти:", tracemalloc.get_traced_memory()[1], "байт")

    # Останавливаем отслеживание памяти
    tracemalloc.stop()

```
## Запуск проекта

1. Перейдите в директорию task4.
2. Перейдите в директорию txtf.
3. Убедитесь, что файл input.txt содержит корректные входные данные в указанном формате.
4. Вернитесь в директорию task4.
5. Перейдите в директорию src.
6. Запустите скрипт:
      python task4.py
   
7. Результат выполнения будет записан в файл output.txt в директории txtf.

## Пример

### Входные данные (input.txt)
```
3
2 7 5
2
2 5
```


### Выходные данные (output.txt)
```
2
```
