# Задача 13: Реализация стека, очереди и связных списков

## Описание первого кода

Этот код реализует стек на основе связного списка.
### Формат входных данных
- Заранее заданные значения 10, 20, 30

### Формат выходных данных
- После добавления элементов в стек, выводится содержимое стека.
После удаления верхнего элемента (в данном случае 30), снова выводится оставшийся стек.

## Описание второго кода

Данный код реализует очередь на основе связного списка с функциями добавления, удаления, просмотра первого элемента и проверки на переполнение или пустоту, с возможностью отслеживания времени работы программы и потребляемой памяти.
### Формат входных данных
- Заранее заданные значения 10, 20, 30, 40

### Формат выходных данных
- Программа выводит информацию о текущем состоянии очереди: Первый элемент очереди через peek(). Удаленный элемент через dequeue(). Попытка добавить элемент в переполненную очередь приводит к ошибке, которая также выводится на экран.
- Программа выводит информацию о времени выполнения и объеме памяти, использованном программой.
- Программа также печатает ошибки, если операции не могут быть выполнены (например, попытка извлечь элемент из пустой очереди).
### Ограничения
- Время выполнения: 2 секунды.
- Память: 256 МБ.

## Структура проекта
```
lab4/
|--   task13/
|     |-- src/
|     |     |-- task13_1.py      # Реализация первого алгоритма
|     |     |-- task13_2.py      # Реализация второго алгоритма
|     |-- tests/
|     |     |-- test_task13_1.py       # Тесты первого алгоритма
|     |     |-- test_task13_1.py       # Тесты второго алгоритма
|     |-- txtf/
|     |     |-- input.txt     # Входные данные
|     |     |-- output.txt    # Выходные данные
```
## Код первой задачи
```
import tracemalloc
import time
# Запускаем таймер для измерения времени работы программы
t_start = time.perf_counter()

# Включаем отслеживание памяти
tracemalloc.start()

class Node:
    """Класс для создания узлов связного списка."""
    def __init__(self, data):
        self.data = data  # Данные, которые хранит узел
        self.next = None  # Ссылка на следующий узел (изначально None)


class Stack:
    """Класс для стека на основе связного списка."""
    def __init__(self):
        self.top = None  # В стеке нет элементов, top указывает на None

    def isEmpty(self):
        """Проверка, пуст ли стек."""
        return self.top is None  # Если top равен None, стек пуст

    def push(self, data):
        """Добавление элемента в стек."""
        new_node = Node(data)  # Создаем новый узел с переданными данными
        new_node.next = self.top  # Новый узел указывает на текущий top
        self.top = new_node  # Теперь новый узел стал верхом стека

    def pop(self):
        """Удаление элемента из стека."""
        if self.isEmpty():
            print("Стек пуст. Невозможно удалить элемент.")
            return None  # Если стек пуст, возвращаем None
        popped_node = self.top  # Сохраняем верхний узел
        self.top = self.top.next  # Теперь top указывает на следующий узел
        return popped_node.data  # Возвращаем данные удаленного элемента

    def print_stack(self):
        """Вывод элементов стека."""
        current = self.top  # Начинаем с верхнего элемента
        if self.isEmpty():
            print("Стек пуст.")
        else:
            while current:  # Пока текущий элемент не равен None
                print(current.data, end=" -> ")  # Выводим данные текущего узла
                current = current.next  # Переходим к следующему элементу
            print("None")  # Конец стека

print("\nTask 13_1")
if __name__ == "__main__":
    # Пример использования стека
    stack = Stack()  # Создаем пустой стек
    stack.push(10)  # Добавляем элемент 10
    stack.push(20)  # Добавляем элемент 20
    stack.push(30)  # Добавляем элемент 30

    print("Стек после добавления элементов:")
    stack.print_stack()  # Выводим стек

    print("\nУдаленный элемент:", stack.pop())  # Удаляем верхний элемент (30)
    print("Стек после удаления элемента:")
    stack.print_stack()  # Выводим стек после удаления элемента
    # Выводим время работы программы
    print("Время работы: %s секунд" % (time.perf_counter() - t_start))
    # Выводим количество памяти, затраченной на выполнение программы
    print("Затрачено памяти:", tracemalloc.get_traced_memory()[1], "байт")

    # Останавливаем отслеживание памяти
    tracemalloc.stop()



```
## Код второй задачи
```
import tracemalloc
import time
# Запускаем таймер для измерения времени работы программы
t_start = time.perf_counter()

# Включаем отслеживание памяти
tracemalloc.start()
class Node:
    """
    Класс для узла связного списка.
    Каждый узел будет хранить значение и ссылку на следующий узел.
    """

    def __init__(self, value):
        self.value = value  # Значение в узле
        self.next = None  # Ссылка на следующий узел


class Queue:
    """
    Класс для очереди, реализованной на основе связного списка.
    """

    def __init__(self, max_size=None):
        self.front = None  # Указатель на начало очереди (первый элемент)
        self.rear = None  # Указатель на конец очереди (последний элемент)
        self.size = 0  # Текущий размер очереди
        self.max_size = max_size  # Максимальный размер очереди (None - неограниченная очередь)

    def is_empty(self):
        """
        Проверка на пустоту очереди.
        """
        return self.size == 0

    def is_full(self):
        """
        Проверка на переполнение очереди.
        Возвращает True, если очередь переполнена.
        """
        if self.max_size is None:
            return False  # Если max_size не задан, очередь не может переполниться
        return self.size == self.max_size

    def enqueue(self, value):
        """
        Добавление элемента в очередь (в конец очереди).
        Если очередь переполнена, выводится ошибка.
        """
        if self.is_full():
            raise OverflowError("Очередь переполнена. Невозможно добавить элемент.")

        new_node = Node(value)

        if self.is_empty():
            self.front = self.rear = new_node  # Если очередь пустая, новый узел будет и первым, и последним
        else:
            self.rear.next = new_node  # Добавляем новый элемент в конец
            self.rear = new_node  # Обновляем указатель на конец очереди

        self.size += 1  # Увеличиваем размер очереди

    def dequeue(self):
        """
        Удаление элемента из очереди (с начала очереди).
        Если очередь пуста, выводится ошибка.
        """
        if self.is_empty():
            raise IndexError("Очередь пуста. Невозможно удалить элемент.")

        dequeued_value = self.front.value  # Сохраняем значение, которое будем удалять
        self.front = self.front.next  # Сдвигаем указатель на начало очереди

        if self.front is None:  # Если после удаления очередь пуста, обновляем указатель на конец
            self.rear = None

        self.size -= 1  # Уменьшаем размер очереди
        return dequeued_value  # Возвращаем значение удалённого элемента

    def peek(self):
        """
        Возвращает элемент, который сейчас в начале очереди, но не удаляет его.
        Если очередь пуста, выводится ошибка.
        """
        if self.is_empty():
            raise IndexError("Очередь пуста. Нет элементов для просмотра.")
        return self.front.value

print("\nTask 13_2")
# Пример использования очереди
if __name__ == "__main__":
    queue = Queue(max_size=3)  # Создаём очередь с максимальным размером 3

    try:
        queue.enqueue(10)
        queue.enqueue(20)
        queue.enqueue(30)

        print(f"Первый элемент в очереди: {queue.peek()}")  # Просмотр первого элемента (10)
        print(f"Удалён элемент: {queue.dequeue()}")  # Удаляем 10
        print(f"Первый элемент в очереди после удаления: {queue.peek()}")  # Просмотр первого элемента (20)

        queue.enqueue(40)  # Добавляем 40
        print(f"Первый элемент в очереди после добавления: {queue.peek()}")  # Просмотр первого элемента (20)

        queue.enqueue(50)  # Попытка добавить 50 в переполненную очередь
        # Выводим время работы программы
        print("Время работы: %s секунд" % (time.perf_counter() - t_start))
        # Выводим количество памяти, затраченной на выполнение программы
        print("Затрачено памяти:", tracemalloc.get_traced_memory()[1], "байт")

        # Останавливаем отслеживание памяти
        tracemalloc.stop()
    except Exception as e:
        print(f"Ошибка: {e}")
        # Выводим время работы программы
        print("Время работы: %s секунд" % (time.perf_counter() - t_start))
        # Выводим количество памяти, затраченной на выполнение программы
        print("Затрачено памяти:", tracemalloc.get_traced_memory()[1], "байт")

        # Останавливаем отслеживание памяти
        tracemalloc.stop()


```
## Запуск проекта

1. Перейдите в директорию task13.
2. Перейдите в директорию src.
3. Запустите скрипт:
      python task13_1.py или python task13_2.py

## Пример

### Входные данные первого алгоритма
```
10
20
30
```

### Выходные данные первого алгоритма
```
Стек после добавления элементов:
30 -> 20 -> 10 -> None

Удаленный элемент: 30
Стек после удаления элемента:
20 -> 10 -> None
```
### Входные данные второго алгоритма
```
10
20
30
40
```


### Выходные данные второго алгоритма
```
Первый элемент в очереди: 10
Удалён элемент: 10
Первый элемент в очереди после удаления: 20
Ошибка: Очередь переполнена. Невозможно добавить элемент.
```
