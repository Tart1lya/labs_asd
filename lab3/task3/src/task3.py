# Импортируем библиотеки для отслеживания памяти и времени выполнения программы
import tracemalloc  # Для отслеживания потребления памяти
import time  # Для измерения времени выполнения
import random  # Для случайных операций (не используется в данном коде, но импортирован)
from lab2.utils import open_file, write_file  # Импортируем функции для чтения и записи файлов

# Запускаем таймер для измерения времени работы программы
t_start = time.perf_counter()  # Засекаем время начала выполнения программы

# Включаем отслеживание памяти
tracemalloc.start()  # Стартуем отслеживание памяти, чтобы в конце узнать, сколько памяти было использовано


# Основная функция, которая проверяет, возможно ли отсортировать массив по описанным правилам
def can_sort(n, k, arr):
    # Разделяем элементы массива на k групп по остатку от деления на k
    groups = [[] for _ in range(k)]  # Создаем список групп, в каждой будет храниться часть элементов массива

    for i in range(n):  # Проходим по всем элементам массива
        groups[i % k].append(arr[i])  # Распределяем элементы по группам с учетом индекса и остатка от деления на k

    # Сортируем каждую группу по отдельности
    for i in range(k):  # Для каждой группы
        groups[i].sort()  # Сортируем элементы внутри группы

    # Воссоздаем отсортированный массив из отсортированных групп
    sorted_arr = []  # Список для хранения результирующего отсортированного массива
    for i in range(n):  # Проходим по всем индексам массива
        sorted_arr.append(groups[i % k].pop(0))  # Берем элементы из отсортированных групп в соответствующем порядке

    # Проверяем, совпадает ли получившийся массив с полностью отсортированным массивом
    if sorted_arr == sorted(arr):  # Если отсортированный массив совпадает с результатом
        return "ДА"  # Возвращаем "ДА", если сортировка возможна
    else:
        return "НЕТ"  # Возвращаем "НЕТ", если сортировка невозможна


# Основной блок программы, который выполняется при запуске скрипта
if __name__ == "__main__":
    # Читаем данные из файла input.txt с помощью функции open_file
    (n_and_k_str, m) = open_file("../txtf/input.txt")  # Считываем данные из файла: первое число n и k, далее массив матрешек
    n, k  = n_and_k_str  # Преобразуем второе число в число k (размах рук)

    # Проверка корректности входных данных: размер массива и элементы
    if (1 <= n <= 10 ** 5) and (all(abs(i) <= 10 ** 9 for i in m)) and (1 <= k <= 10 ** 5):
        # Если данные корректны (n в пределах от 1 до 10^5, элементы массива в пределах от -10^9 до 10^9, k в пределах от 1 до 10^5)

        # Сортируем массив m с помощью функции can_sort
        result = can_sort(n, k, m)  # Проверяем, можем ли отсортировать массив по правилам

        # Записываем результат в файл output.txt
        write_file(result, "../txtf/output.txt")  # Записываем ответ ("ДА" или "НЕТ") в файл output.txt
    else:
        # Выводим сообщение об ошибке, если данные некорректны
        print('Введите корректные данные')  # Если данные не соответствуют ограничениям, выводим ошибку

    # Выводим время работы программы
    print("Время работы: %s секунд" % (
                time.perf_counter() - t_start))  # Выводим время работы программы, рассчитанное с начала выполнения

    # Выводим количество памяти, затраченной на выполнение программы
    print("Затрачено памяти:", tracemalloc.get_traced_memory()[1],
          "байт")  # Выводим максимальное количество памяти, затраченное на выполнение программы

    # Останавливаем отслеживание памяти
    tracemalloc.stop()  # Останавливаем отслеживание памяти после завершения программы
